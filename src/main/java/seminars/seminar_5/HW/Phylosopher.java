package seminars.seminar_5.HW;

import java.util.concurrent.locks.Lock;

public class Phylosopher implements Runnable{

    private final int idP;
    private final Lock leftFork;
    private final Lock rightFork;

    public Phylosopher(int idP, Lock leftFork, Lock rightFork) {
        this.idP = idP;
        this.leftFork = leftFork;
        this.rightFork = rightFork;
    }
    // метод думать создать

    // метод кушать создать
    @Override
    public void run() {
        
    }
}

/*
`ReentrantLock` - это класс из пакета `java.util.concurrent.locks`, представляющий собой реализацию объекта блокировки
(lock). Этот класс предоставляет более гибкий и расширенный способ управления синхронизацией потоков в Java, чем
традиционные `synchronized` блоки.
`ReentrantLock` поддерживает реентерабельность блокировки, что означает, что один и тот же поток может многократно
захватывать и освобождать блокировку внутри себя без блокирования. Это полезно в ситуациях, когда реентерабельная
блокировка требует дополнительного уровня гибкости для организации синхронизации в сложных сценариях многопоточного
программирования.
`ReentrantLock` предоставляет богатый набор методов для управления блокировкой, включая `lock()` для захвата блокировки,
`unlock()` для освобождения блокировки, `tryLock()` для попытки захвата блокировки без блокирования потока, а также
различные методы для работы с условиями (`Condition`) и таймаутами.
Использование `ReentrantLock` может быть предпочтительным в случаях, когда требуется более сложное управление
блокировкой и когда необходимо избежать некоторых недостатков `synchronized` блоков, таких как невозможность попытки
захвата блокировки.
 */
